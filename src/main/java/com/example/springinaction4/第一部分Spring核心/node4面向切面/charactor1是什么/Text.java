package com.example.springinaction4.第一部分Spring核心.node4面向切面.charactor1是什么;

/**
 * 在软件开发中，散布于应用中多处的功能被称为横切关注点（cross-cutting concern）。通常来讲，这些横切关注点从概念上是与应用的业务逻辑相分离的（但是往往会直接嵌入到应用的业务逻辑之中）。
 * 把这些横切关注点与业务逻辑相分离正是面向切面编程（AOP）所要解决的问题。
 * 在第2章，我们介绍了如何使用依赖注入（DI）管理和配置我们的应用对象。DI有助于应用对象之间的解耦，而AOP可以实现横切关注点与它们所影响的对象之间的解耦。
 * 日志是应用切面的常见范例，但它并不是切面适用的唯一场景。通览本书，我们还会看到切面所适用的多个场景，包括声明式事务、安全和缓存。
 * 本章展示了Spring对切面的支持，包括如何把普通类声明为一个切面和如何使用注解创建切面。除此之外，我们还会看到AspectJ——另一种流行的AOP实现——如何补充Spring AOP框架的功能。
 * 但是，我们先不管事务、安全和缓存，先看一下Spring是如何实现切面的， 就从AOP的基础知识开始吧。
 */

/**
 * 如前所述，切面能帮助我们模块化横切关注点。简而言之，横切关注点可以被描述为影响应用多处的功能。例如， 安全就是一个横切关注点， 应用中的许多方法都会涉及到安全规则。
 *
 * 展现了一个被划分为模块的典型应用。每个模块的核心功能都是为特定业务领域提供服务， 但是这些模块都需要类似的辅助功能，例如安全和事务管理。
 * 如果要重用通用功能的话，最常见的面向对象技术是继承（inheritance）或委托（delegation）。但是，如果在整个应用中都使用相同的基类，继承往往会导致一个脆弱的对象体系;而使用委托可能需要对委托对象进行复杂的调用。
 * 切面提供了取代继承和委托的另一种可选方案， 而且在很多场景下更清晰简洁。在使用面向切面编程时，我们仍然在一个地方定义通用功能，但是可以通过声明的方式定义这个功能要以何种方式在何处应用，而无需修改受影响的类。
 * 横切关注点可以被模块化为特殊的类，这些类被称为切面（aspect）。
 * 这样做有两个好处∶首先，现在每个关注点都集中于一个地方，而不是分散到多处代码中;其次，服务模块更简洁， 因为它们只包含主要关注点（或核心功能）的代码，而次要关注点的代码被转移到切面中了。
 */

/**
 * APO术语
 *      通知（Advice）
 *              类似地，切面也有目标——它必须要完成的工作。在AOP术语中，切面的工作被称为通知。通知定义了切面是什么以及何时使用。除了描述切面要完成的工作，通知还解决了何时执行这个工作的问题。
 *              它应该应用在某个方法被调用之前?之后?之前和之后都调用?还是只在方法抛出异常时调用?Spring切面可以应用5种类型的通知∶
 *                  ●前置通知（Before）∶在目标方法被调用之前调用通知功能∶
 *                  ●后置通知（After）∶在目标方法完成之后调用通知，此时不会关心方法的输出是什么;
 *                  ● 返回通知（After-returning）∶在目标方法成功执行之后调用通知;
 *                  ●异常通知（After-throwing）∶在目标方法抛出异常后调用通知;
 *                  ●环绕通知（Around）∶通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。
*       连接点（Join point）
 *              电力公司为多个住户提供服务，甚至可能是整个城市。每家都有一个电表，这些电表上的数字都需要读取，因此每家都是抄表员的潜在目标。抄表员也许能够读取各种类型的设备，但是为了完成他的工作，
 *              他的目标应该房屋内所安装的电表。
 *              同样，我们的应用可能也有数以千计的时机应用通知。这些时机被称为连接点。连接点是在应用执行过程中能够插入切面的一个点。
 *              这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。
 *      切点（Poincut）
 *              如果让一位抄表员访问电力公司所服务的所有住户，那肯定是不现实的。实际上，电力公司为每一个抄表员都分别指定某一块区域的住户。
 *              类似地，一个切面并不需要通知应用的所有连接点。切点有助于缩小切面所通知的连接点的范围。如果说通知定义了切面的"什么"和"何时"的话， 那么切点就定义了"何处"。
 *              切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称， 或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。
 *              有些AOP框架允许我们创建动态的切点，可以根据运行时的决策（比如方法的参数值）来决定是否应用通知。
 *      切面（Aspect）
 *              当抄表员开始一天的工作时，他知道自己要做的事情（报告用电量）和从哪些房屋收集信息。因此，他知道要完成工作所需要的一切东西。
 *              切面是通知和切点的结合。通知和切点共同定义了切面的全部内容———它是什么，在何时和何处完成其功能。
 *      引入（Introduction）
 *              引入允许我们向现有的类添加新方法或属性。例如，我们可以创建一个Auditable通知类，该类记录了对象最后一次修改时的状态。
 *              这很简单，只需一个方法，setLastModified（Date），和一个实例变量来保存这个状态。
 *              然后，这个新方法和实例变量就可以被引入到现有的类中，从而可以在无需修改这些现有的类的情况下，让它们具有新的行为和状态。
 *      织人（Weaving）
 *              织入是把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。在目标对象的生命周期里有多个点可以进行织入∶
 *                  ●编译期∶切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。
 *                  ●类加载期∶切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器（ClassLoader），它可以在目标类被引入应用之前增强该目标类的字节码。
 *                      AspectJ 5的加载时织人（load-time weaving， LTW）就支持以这种方式织人切面。
 *                  ●运行期∶切面在应用运行的某个时刻被织入。一般情况下，在织入切面时， AOP容器会为目标对象动态地创建一个代理对象。Spring AOP就是以这种方式织入切面的。
 *
 *      通知包含了需要用于多个应用对象的横切行为;
 *      连接点是程序执行过程中能够应用通知的所有点;
 *      切点定义了通知被应用的具体位置（在哪些连接点）。其中关键的概念是切点定义了哪些连接点会得到通知。
 *
 */

/**
 * 并不是所有的AOP框架都是相同的，它们在连接点模型上可能有强弱之分。有些允许在字段修饰符级别应用通知，而另一些只支持与方法调用相关的连接点。它们织入切面的方式和时机也有所不同。
 * 但是无论如何，创建切点来定义切面所织入的连接点是AOP框架的基本功能。虽然如此，Spring和AspectJ项目之间有大量的协作，而且Spring对AOP的支持在很多方面借鉴了 AspectJ项目。
 * Spring提供了4种类型的AOP支持∶
 *      ●基于代理的经典Spring AOP;
 *      ●纯POJO切面;
 *      ●@AspectJ注解驱动的切面;
 *      ●注人式AspectJ切面（适用于Spring各版本）。
 * 前三种都是Spring AOP实现的变体， Spring AOP构建在动态代理基础之上，因此， Spring对AOP的支持局限于方法拦截。术语"经典"通常意味着是很好的东西。
 * 但是Spring的经典AOP编程模型并不怎么样。当然，會经它的确非常棒。但是现在Spring提供了更简洁和干净的面向切面编程方式。
 * 引入了简单的声明式AOP和基于注解的AOP之后， Spring经典的AOP看起来就显得非常笨重和过干复杂，直接使用 ProxyFactory Bean会让人感觉厌烦。
 * 所以在本书中我不会再介绍经典的Spring AOP。借助Spring的aop命名空间，我们可以特纯POJO转换为切面。实际上，这些POJO只是提供了满足切点条件时所要调用的方法。
 * 遗憾的是，这种技术需要XML配置，但这的确是声明式地捋对象转换为切面的简便方式。
 *
 * Spring借鉴了AspectJ的切面，以提供注解驱动的AOP。本质上，它依然是Spring基于代理的 AOP，但是编程模型几乎与编写成熟的AspectJ注解切面完全一致。这种AOP风格的好处在于能够不使用XML来完成功能。
 * 如果你的AOP需求超过了简单的方法调用（如构造器或属性拦截），那么你需要考虑使用 AspectJ来实现切面。在这种情况下，上文所示的第四种类型能够帮助你特值注入到AspectJ驱动的切面中。
 * 我们在将在本章展示更多的Spring AOP技术，但是在开始之前，我们必须要了解Spring AOP框架的一些关键知识。
 *
 * Spring所创建的通知都是用标准的Java类编写的。
 * 这样的话，我们就可以使用与普通Java开发一样的集成开发环境（IDE）来开发切面。而且， 定义通知所应用的切点通常会使用注解或在 Spring配置文件里采用XML来编写，这两种语法对于Java开发者来说都是相当熟悉的。
 *  Aspect与之相反。虽然AspectU现在支持基于注解的切面，但AspectJ最初是以Java语言扩展的方式实现的。
 * 这种方式有优点也有缺点。通过特有的AOP语言，我们可以获得更强大和细粒度的控制，以及更丰富的AOP工具集. 但是我们需要额外学习新的工具和语法。
 *
 * Spring在运行时通知对象
 *      通过在代理类中包裹切面，Spring在运行期把切面织入到Spring管理的bean中。如图4.3所示，代理类封装了目标类，并拦截被通知方法的调用， 再把调用转发给真正的目标bean。
 *      当代理拦截到方法调用时，在调用目标bean方法之前，会执行切面逻辑。直到应用需要被代理的bean时， Spring才创建代理对象。
 *      如果使用的是ApplicationContext的话，在ApplicationContext从BeanFactory中加载所有 bean的时候， Spring才会创建被代理的对象。
 *      因为Spring运行时才创建代理对象，所以我们不需要特殊的编译器来织人Spring AOP的切面。
 *
 * Spring只支持方法级别的连接点
 *      正如前面所探讨过的，通过使用各种AOP方案可以支持多种连接点模型。因为Spring基于动态代理，所以Spring只支持方法连接点。
 *      这与一些其他的AOP框架是不同的，例如AspectUJ和 JBoss，除了方法切点，它们还提供了字段和构造器接入点。Spring缺少对字段连接点的支持，无法让我们创建细粒度的通知，例如拦截对象字段的修改。
 *      而且它不支持构造器连接点，我们就无法在bean创建时应用通知。但是方法拦截可以满足绝大部分的需求。如果需要方法拦截之外的连接点拦截功能，那么我们可以利用Aspect来补充Spring AOP的功能。
 *
 *      对于什么是AOP以及Spring如何支持AOP的，我们现在已经有了一个大致的了解。现在是时候学习如何在Spring中创建切面了，让我们先从Spring的声明式AOP模型开始。
 *
 *
 */

public class Text {
}














